<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MacAtlas v5.1 - Logic Fix</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #888;
            --window-bg: #ffffff;
            --border-color: #000000;
        }
        
        * { box-sizing: border-box; }

        body {
            font-family: 'VT323', monospace;
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; 
            height: 100dvh;
            overflow: hidden; 
            background-image: 
                linear-gradient(45deg, #aaa 25%, transparent 25%), 
                linear-gradient(-45deg, #aaa 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #aaa 75%), 
                linear-gradient(-45deg, transparent 75%, #aaa 75%);
            background-size: 2px 2px;
            user-select: none;
        }

        /* RETRO MAC WINDOW */
        #main-window {
            width: 95%;
            max-width: 900px;
            height: 90vh;
            background: var(--window-bg);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 5px 5px 0px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #title-bar {
            background: repeating-linear-gradient(to bottom, #000, #000 1px, #fff 1px, #fff 2px);
            height: 24px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: default;
            flex-shrink: 0;
        }

        #title-text {
            background: #fff;
            padding: 0 10px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }

        #close-btn {
            position: absolute;
            left: 6px;
            width: 12px;
            height: 12px;
            border: 1px solid #000;
            background: #fff;
            box-shadow: 1px 1px 0 #000;
        }

        /* CONTENT AREA */
        #content {
            flex: 1;
            padding: 20px;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        /* SCREEN MANAGEMENT */
        .screen {
            display: none;
            width: 100%;
            flex: 1; 
            min-height: 0; 
            flex-direction: column;
            align-items: center;
        }

        .screen.active { display: flex; }

        h1 {
            font-size: 48px;
            margin: 20px 0;
            text-align: center;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 #ccc;
        }

        .btn {
            background: #fff;
            border: 2px solid #000;
            padding: 10px 30px;
            margin: 10px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 3px 3px 0 #000;
            transition: transform 0.1s, box-shadow 0.1s;
            min-width: 250px;
            text-align: center;
        }

        .btn:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0 #000; }
        .btn:hover { background: #eee; }

        /* GAME HUD */
        #hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            border-bottom: 2px dashed #000;
            padding-bottom: 10px;
            margin-bottom: 10px;
            font-size: 24px;
            flex-shrink: 0;
        }

        /* MAP GAME & ZOOM CONTROLS */
        #map-container {
            flex: 1;
            width: 100%;
            position: relative;
            background: #f0f8ff;
            border: 2px solid #000;
            overflow: hidden;
            touch-action: none;
            cursor: grab;
        }

        #map-container:active {
            cursor: grabbing;
        }
        
        #zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: #fff;
            border: 2px solid #000;
            font-family: 'VT323', monospace;
            font-size: 24px;
            line-height: 24px;
            text-align: center;
            cursor: pointer;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .zoom-btn:active { transform: translate(1px, 1px); box-shadow: 1px 1px 0 rgba(0,0,0,0.5); }
        
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        path {
            fill: #fff;
            stroke: #000;
            stroke-width: 1;
            cursor: pointer;
            transition: fill 0.2s;
            vector-effect: non-scaling-stroke;
        }
        
        #map-container path:hover { fill: #ddd; }
        #map-container path.correct { fill: #444 !important; color: white; }
        #map-container path.highlighted { animation: blink 1s infinite; fill: #888 !important; }
        #map-container path.wrong { fill: #000 !important; }

        /* PUZZLE SPECIFIC STYLES */
        #puzzle-area {
            flex: 1;
            width: 100%;
            border: 2px solid #000;
            background: #f0f8ff;
            position: relative;
            overflow: hidden;
            touch-action: none;
            min-height: 0;
        }

        .puzzle-base { fill: #444; stroke: #000; stroke-width: 1; }
        .puzzle-target { fill: none; stroke: #888; stroke-width: 1; stroke-dasharray: 5,5; }
        
        .puzzle-piece {
            fill: #fff; stroke: #000; stroke-width: 1;
            cursor: grab; filter: drop-shadow(3px 3px 0px rgba(0,0,0,0.3));
            transition: transform 0.1s;
        }
        .puzzle-piece.dragging {
            cursor: grabbing; fill: #eee;
            filter: drop-shadow(5px 5px 0px rgba(0,0,0,0.5));
            transition: none; z-index: 1000;
        }
        .puzzle-piece.snapped {
            fill: #444; cursor: default; filter: none; transition: fill 0.5s;
        }
        .puzzle-label {
            font-family: 'VT323', monospace; fill: #fff; font-size: 14px;
            text-anchor: middle; dominant-baseline: middle; pointer-events: none; 
            text-shadow: 1px 1px 0 #000; opacity: 0; animation: fadeIn 0.5s forwards; font-weight: bold;
        }
        
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        @keyframes blink { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* FEEDBACK BAR */
        #feedback-bar {
            margin-top: 10px; width: 100%; height: 40px; border: 2px solid #000;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; background: #eee; transition: background 0.2s;
            visibility: hidden; flex-shrink: 0; 
        }

        #feedback-bar.visible { visibility: visible; }
        #feedback-bar.correct { background: #000; color: #fff; }
        #feedback-bar.wrong { background: repeating-linear-gradient(45deg, #fff, #fff 10px, #ccc 10px, #ccc 20px); color: #000; font-weight: bold; }

        /* QUIZ UI */
        .quiz-area {
            flex: 1; width: 100%; display: flex; flex-direction: column;
            justify-content: center; align-items: center; overflow: hidden; 
        }

        #capital-prompt, #trivia-prompt {
            font-size: 28px; margin-bottom: 10px; text-align: center; max-width: 800px; line-height: 1.2;
        }

        #capital-state-preview {
            height: 200px; width: 100%; max-width: 300px; margin: 10px 0;
            display: flex; justify-content: center; align-items: center;
        }
        
        #capital-state-preview svg { filter: drop-shadow(4px 4px 0px rgba(0,0,0,0.2)); }
        #capital-state-preview path { fill: #ddd; stroke: #000; stroke-width: 2; cursor: default; }

        #capital-state-name, #trivia-state-name {
            font-size: 48px; font-weight: bold; margin-bottom: 20px;
            text-decoration: underline; text-align: center;
        }
        
        #trivia-question-text {
            font-size: 32px; text-align: center; margin: 20px;
            max-width: 700px; min-height: 100px; display: flex; align-items: center; justify-content: center;
        }

        #options-grid, #trivia-options-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px;
        }

        .option-btn {
            background: #fff; border: 2px solid #000; padding: 12px;
            font-family: 'VT323', monospace; font-size: 24px; cursor: pointer;
            box-shadow: 4px 4px 0 #000; transition: all 0.1s; text-align: center;
            display: flex; align-items: center; justify-content: center; min-height: 60px; line-height: 1.1;
        }

        .option-btn:hover { background: #eee; }
        .option-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #000; }
        .option-btn.correct-anim { background: #000; color: #fff; }
        .option-btn.wrong-anim { opacity: 0.5; background: #aaa; text-decoration: line-through; }

        /* REPORT CARD MODAL */
        #report-modal {
            display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9); z-index: 100; flex-direction: column;
            justify-content: center; align-items: center;
        }

        #report-card {
            background: #fff; border: 4px double #000; padding: 40px; text-align: center; box-shadow: 10px 10px 0 rgba(0,0,0,0.2);
        }

        .shake-effect { animation: shake 0.5s; }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body>

    <div id="main-window">
        <div id="title-bar">
            <div id="close-btn" onclick="quitGame()"></div>
            <div id="title-text">MacAtlas v5.1</div>
        </div>

        <div id="content">

            <!-- MENU SCREEN (Active by default) -->
            <div id="menu-screen" class="screen active">
                <h1>MacAtlas</h1>
                <p style="text-align:center; font-size: 20px;">USA EDITION</p>
                <div style="height: 20px;"></div>
                <button class="btn" onclick="startGame('map')">FIND THE STATE</button>
                <button class="btn" onclick="startGame('capitals')">NAME THE CAPITAL</button>
                <button class="btn" onclick="startGame('trivia')">STATE TRIVIA</button>
                <button class="btn" onclick="startGame('puzzle')">REGION PUZZLE</button>
            </div>

            <!-- GAME SCREEN -->
            <div id="game-screen" class="screen">
                <div id="hud">
                    <span id="score-display">SCORE: 000</span>
                    <span id="timer-display">TIME: 00:00</span>
                    <button style="font-family:'VT323'; background:none; border:1px solid #000; cursor:pointer;" onclick="quitGame()">QUIT</button>
                </div>

                <!-- MAP MODE ELEMENTS -->
                <div id="map-game-ui" style="display:none; width: 100%; flex: 1; min-height: 0; flex-direction: column;">
                    <div id="map-container">
                        <!-- SVG injected here -->
                        <div id="zoom-controls">
                            <div class="zoom-btn" onclick="zoomMap(1.2)">+</div>
                            <div class="zoom-btn" onclick="zoomMap(0.8)">-</div>
                            <div class="zoom-btn" onclick="resetZoom()">R</div>
                        </div>
                    </div>
                    <div id="feedback-bar" class="visible">Locating Data...</div>
                </div>

                <!-- CAPITALS MODE ELEMENTS -->
                <div id="capitals-game-ui" style="display:none; width: 100%; flex: 1; min-height: 0; flex-direction: column; align-items: center;">
                    <div class="quiz-area">
                        <div id="capital-prompt">WHAT IS THE CAPITAL OF</div>
                        <div id="capital-state-preview"></div>
                        <div id="capital-state-name">CALIFORNIA</div>
                        
                        <div id="options-grid">
                            <button class="option-btn" id="opt-0" onclick="checkCapital(0)">SACRAMENTO</button>
                            <button class="option-btn" id="opt-1" onclick="checkCapital(1)">AUSTIN</button>
                            <button class="option-btn" id="opt-2" onclick="checkCapital(2)">BOSTON</button>
                            <button class="option-btn" id="opt-3" onclick="checkCapital(3)">ALBANY</button>
                        </div>
                    </div>
                    <div id="feedback-bar" style="margin-top:auto;"></div>
                </div>

                <!-- TRIVIA MODE ELEMENTS -->
                <div id="trivia-game-ui" style="display:none; width: 100%; flex: 1; min-height: 0; flex-direction: column; align-items: center;">
                    <div class="quiz-area">
                        <div id="trivia-prompt">TRIVIA TIME</div>
                        <div id="trivia-state-name">ALABAMA</div>
                        <div id="trivia-question-text">Question goes here...</div>
                        
                        <div id="trivia-options-grid">
                            <button class="option-btn" id="triv-0" onclick="checkTrivia(0)">Option A</button>
                            <button class="option-btn" id="triv-1" onclick="checkTrivia(1)">Option B</button>
                            <button class="option-btn" id="triv-2" onclick="checkTrivia(2)">Option C</button>
                            <button class="option-btn" id="triv-3" onclick="checkTrivia(3)">Option D</button>
                        </div>
                    </div>
                    <div id="feedback-bar" style="margin-top:auto;"></div>
                </div>

                <!-- PUZZLE MODE ELEMENTS -->
                <div id="puzzle-game-ui" style="display:none; width: 100%; flex: 1; min-height: 0; flex-direction: column; align-items: center;">
                    <div style="font-size:24px; margin-bottom:5px; flex-shrink: 0;" id="puzzle-region-name">REGION: WEST COAST</div>
                    <div id="puzzle-area">
                        <!-- SVG injected here -->
                    </div>
                    <div id="feedback-bar" class="visible" style="margin-top:10px;">DRAG THE PIECES TO THE DOTTED LINES</div>
                </div>

            </div>

            <!-- REPORT MODAL -->
            <div id="report-modal">
                <div id="report-card">
                    <h2>REPORT CARD</h2>
                    <h1 id="report-percent" style="font-size:80px; margin: 10px 0;">100%</h1>
                    <p id="report-fraction">10 / 10 Correct</p>
                    <button class="btn" onclick="closeReport()">OK</button>
                </div>
            </div>

        </div>
    </div>

<script>
    // --- GLOBAL STATE ---
    const state = {
        allData: [],
        triviaData: [],
        puzzleData: [],
        gameMode: null,
        score: 0,
        startTime: 0,
        timerInterval: null,
        pool: [],
        currentIdx: 0,
        
        // Map Game Specifics
        roundAttempts: 0,
        roundResolved: false,

        // Map Viewport (Zoom/Pan)
        viewBox: { x: 0, y: 0, w: 959, h: 593 },
        isPanning: false,
        lastPan: { x: 0, y: 0 },

        // Stats for report
        testTotal: 0,
        testCorrect: 0,

        // Quiz specific
        currentOptions: [],
        currentCorrectIndex: -1,

        // Puzzle Specific
        draggedElement: null,
        dragOffset: { x: 0, y: 0 },
        puzzlePiecesLeft: 0
    };

    const SVG_WIDTH = 959;
    const SVG_HEIGHT = 593;

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
    }

    // --- INITIALIZATION ---
    async function loadAllData() {
        try {
            const mapRes = await fetch('state_data.json');
            if (!mapRes.ok) throw new Error("Could not load state_data.json");
            const mapData = await mapRes.json();
            if(!Array.isArray(mapData)) throw new Error("Map JSON is not array");
            state.allData = mapData;

            const trivRes = await fetch('trivia_data.json');
            if (trivRes.ok) {
                state.triviaData = await trivRes.json();
            }

            const puzRes = await fetch('puzzle_data.json');
            if (puzRes.ok) {
                state.puzzleData = await puzRes.json();
            }

            renderMap();
            
        } catch (e) {
            console.error(e);
            alert("Error loading data. Ensure json files are present.");
        }
    }

    function renderMap() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(ns, "svg");
        // Use state viewBox
        svg.setAttribute("viewBox", `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.w} ${state.viewBox.h}`);
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        svg.setAttribute("id", "main-map-svg");

        state.allData.forEach(s => {
            const path = document.createElementNS(ns, "path");
            path.setAttribute("d", s.path);
            path.setAttribute("id", "map-" + s.name.replace(/\s/g, '')); 
            path.setAttribute("data-name", s.name);
            
            // IMPORTANT: Removed native click listener here to prevent double-fire
            // logic is now handled exclusively in endPan()
            
            svg.appendChild(path);
        });

        const container = document.getElementById('map-container');
        // Clear old SVG but keep controls
        const controls = container.querySelector('#zoom-controls');
        container.innerHTML = '';
        if(controls) container.appendChild(controls);
        container.appendChild(svg);

        // --- ADD PANNING LISTENERS ---
        container.addEventListener('mousedown', startPan);
        container.addEventListener('mousemove', doPan);
        container.addEventListener('mouseup', endPan);
        container.addEventListener('mouseleave', endPan);
        
        container.addEventListener('touchstart', startPan, {passive: false});
        container.addEventListener('touchmove', doPan, {passive: false});
        container.addEventListener('touchend', endPan);
    }

    // --- ZOOM & PAN LOGIC ---
    
    function updateViewBox() {
        const svg = document.getElementById('main-map-svg');
        if(svg) {
            svg.setAttribute("viewBox", `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.w} ${state.viewBox.h}`);
        }
    }

    function zoomMap(factor) {
        // Zoom center
        const cx = state.viewBox.x + state.viewBox.w / 2;
        const cy = state.viewBox.y + state.viewBox.h / 2;

        const newW = state.viewBox.w / factor;
        const newH = state.viewBox.h / factor;

        state.viewBox.x = cx - newW / 2;
        state.viewBox.y = cy - newH / 2;
        state.viewBox.w = newW;
        state.viewBox.h = newH;
        
        updateViewBox();
    }

    function resetZoom() {
        state.viewBox = { x: 0, y: 0, w: SVG_WIDTH, h: SVG_HEIGHT };
        updateViewBox();
    }

    // Pan Logic
    let isClick = true; // Distinguish click from drag

    function startPan(e) {
        // Don't pan if clicking buttons
        if (e.target.closest('#zoom-controls')) return;
        
        e.preventDefault();
        state.isPanning = true;
        isClick = true;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        state.lastPan = { x: clientX, y: clientY };
    }

    function doPan(e) {
        if (!state.isPanning) return;
        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const dx = clientX - state.lastPan.x;
        const dy = clientY - state.lastPan.y;

        // Threshold for determining drag vs click
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) isClick = false;

        // Convert pixels to SVG units
        const container = document.getElementById('map-container');
        const ratio = state.viewBox.w / container.clientWidth;

        state.viewBox.x -= dx * ratio;
        state.viewBox.y -= dy * ratio;

        state.lastPan = { x: clientX, y: clientY };
        updateViewBox();
    }

    function endPan(e) {
        if (!state.isPanning) return;
        state.isPanning = false;
        
        // SINGLE SOURCE OF TRUTH FOR CLICKS
        if (isClick && state.gameMode === 'map') {
            let target = e.target;
            
            // For touch, e.target is often the container, not the element underneath
            if (e.changedTouches && e.changedTouches.length > 0) {
                 const t = e.changedTouches[0];
                 target = document.elementFromPoint(t.clientX, t.clientY);
            }
            
            if (target && target.tagName === 'path' && target.hasAttribute('data-name')) {
                const name = target.getAttribute('data-name');
                const sObj = state.allData.find(s => s.name === name);
                if(sObj) handleMapClick(sObj);
            }
        }
    }


    // --- GAME LOOP ---

    function startGame(mode) {
        if (state.allData.length === 0) {
            alert("Still loading data... please wait a moment.");
            return;
        }

        state.gameMode = mode;
        state.score = 0;
        state.testTotal = 0;
        state.testCorrect = 0;
        state.startTime = Date.now();
        state.currentIdx = 0;
        resetZoom(); // Always reset zoom on start

        const feedback = document.querySelectorAll('#feedback-bar');
        feedback.forEach(f => {
            f.classList.remove('visible');
            f.className = ''; 
        });

        // POOL SETUP
        if (mode === 'map' || mode === 'capitals') {
            state.pool = [...state.allData].sort(() => 0.5 - Math.random());
            state.pool = state.pool.slice(0, 10);
        } else if (mode === 'trivia') {
            state.pool = [...state.triviaData].sort(() => 0.5 - Math.random());
            state.pool = state.pool.slice(0, 10);
        } else if (mode === 'puzzle') {
            state.pool = [...state.puzzleData].sort(() => 0.5 - Math.random());
            state.pool = state.pool.slice(0, 5);
        }

        document.getElementById('score-display').innerText = "SCORE: 0";
        showScreen('game-screen');

        if (state.timerInterval) clearInterval(state.timerInterval);
        state.timerInterval = setInterval(updateTimer, 1000);

        // UI TOGGLE
        document.getElementById('map-game-ui').style.display = 'none';
        document.getElementById('capitals-game-ui').style.display = 'none';
        document.getElementById('trivia-game-ui').style.display = 'none';
        document.getElementById('puzzle-game-ui').style.display = 'none';

        if (mode === 'map') {
            document.getElementById('map-game-ui').style.display = 'flex';
            document.querySelector('#map-game-ui #feedback-bar').classList.add('visible');
            loadMapRound();
        } else if (mode === 'capitals') {
            document.getElementById('capitals-game-ui').style.display = 'flex';
            loadCapitalRound();
        } else if (mode === 'trivia') {
            document.getElementById('trivia-game-ui').style.display = 'flex';
            loadTriviaRound();
        } else if (mode === 'puzzle') {
            document.getElementById('puzzle-game-ui').style.display = 'flex';
            document.querySelector('#puzzle-game-ui #feedback-bar').classList.add('visible');
            loadPuzzleRound();
        }
    }

    function quitGame() {
        if (state.timerInterval) clearInterval(state.timerInterval);
        document.getElementById('report-modal').style.display = 'none';
        showScreen('menu-screen');
    }

    function updateTimer() {
        const delta = Math.floor((Date.now() - state.startTime) / 1000);
        const m = Math.floor(delta / 60).toString().padStart(2, '0');
        const s = (delta % 60).toString().padStart(2, '0');
        document.getElementById('timer-display').innerText = `TIME: ${m}:${s}`;
    }

    // --- PUZZLE GAME LOGIC ---

    function loadPuzzleRound() {
        if (state.currentIdx >= state.pool.length) {
            showReport();
            return;
        }

        const levelData = state.pool[state.currentIdx];
        document.getElementById('puzzle-region-name').innerText = `REGION: ${levelData.name.toUpperCase()}`;
        
        const feedback = document.querySelector('#puzzle-game-ui #feedback-bar');
        feedback.innerText = "DRAG THE PIECES TO THE DOTTED LINES";
        feedback.className = 'visible';

        const container = document.getElementById('puzzle-area');
        container.innerHTML = '';
        const ns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(ns, "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        
        const baseState = state.allData.find(s => s.name === levelData.base);
        const piecesStates = levelData.pieces.map(pName => state.allData.find(s => s.name === pName));
        
        if (!baseState || piecesStates.some(p => !p)) {
            console.error("Missing puzzle data", levelData);
            nextPuzzleRound();
            return;
        }

        state.puzzlePiecesLeft = piecesStates.length;

        // Base
        const basePath = document.createElementNS(ns, "path");
        basePath.setAttribute("d", baseState.path);
        basePath.setAttribute("class", "puzzle-base");
        svg.appendChild(basePath);
        setTimeout(() => addLabelToPuzzlePiece(basePath, baseState.name, svg), 100);

        // Targets
        piecesStates.forEach(p => {
            const targetPath = document.createElementNS(ns, "path");
            targetPath.setAttribute("d", p.path);
            targetPath.setAttribute("class", "puzzle-target");
            svg.appendChild(targetPath);
        });

        // Pieces
        piecesStates.forEach((p, index) => {
            const piece = document.createElementNS(ns, "path");
            piece.setAttribute("d", p.path);
            piece.setAttribute("class", "puzzle-piece");
            piece.setAttribute("data-id", p.name); 
            
            const offsetX = (Math.random() * 120) - 60;
            const offsetY = (Math.random() * 120) - 60;
            
            piece.dataset.tx = offsetX;
            piece.dataset.ty = offsetY;
            piece.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
            
            piece.addEventListener('mousedown', startDrag);
            piece.addEventListener('touchstart', startDrag, {passive: false});
            
            svg.appendChild(piece);
        });

        container.appendChild(svg);

        // Calculate ViewBox with EXTRA EXTRA PADDING (300px)
        setTimeout(() => {
            try {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                svg.querySelectorAll('path').forEach(p => {
                    const bbox = p.getBBox();
                    if (bbox.x < minX) minX = bbox.x;
                    if (bbox.y < minY) minY = bbox.y;
                    if (bbox.x + bbox.width > maxX) maxX = bbox.x + bbox.width;
                    if (bbox.y + bbox.height > maxY) maxY = bbox.y + bbox.height;
                });

                const pad = 300; // Increased to ensure no clipping
                const width = maxX - minX + (pad * 2);
                const height = maxY - minY + (pad * 2);
                
                svg.setAttribute("viewBox", `${minX - pad} ${minY - pad} ${width} ${height}`);
            } catch (e) {
                console.error("Zoom calc failed", e);
                svg.setAttribute("viewBox", `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`);
            }
        }, 50);

        svg.addEventListener('mousemove', drag);
        svg.addEventListener('touchmove', drag, {passive: false});
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('touchend', endDrag);
        svg.addEventListener('mouseleave', endDrag);
    }
    
    function addLabelToPuzzlePiece(pathElement, text, svgContainer) {
        try {
            const bbox = pathElement.getBBox();
            const cx = bbox.x + bbox.width / 2;
            const cy = bbox.y + bbox.height / 2;
            
            const ns = "http://www.w3.org/2000/svg";
            const textEl = document.createElementNS(ns, "text");
            textEl.setAttribute("x", cx);
            textEl.setAttribute("y", cy);
            textEl.setAttribute("class", "puzzle-label");
            textEl.textContent = text.toUpperCase();
            
            if (bbox.width < 20 || bbox.height < 20) {
               textEl.setAttribute("font-size", "10px"); 
            }

            svgContainer.appendChild(textEl);
        } catch(e) {}
    }

    // --- DRAG LOGIC (Puzzle) ---
    function startDrag(e) {
        e.preventDefault();
        const svg = document.querySelector('#puzzle-area svg');
        const piece = e.target;
        
        if (piece.classList.contains('snapped')) return;

        state.draggedElement = piece;
        piece.classList.add('dragging');
        
        const feedback = document.querySelector('#puzzle-game-ui #feedback-bar');
        feedback.innerText = "MOVING: " + piece.dataset.id.toUpperCase();
        feedback.className = 'visible';
        
        svg.appendChild(piece);

        const pt = getEventPoint(e, svg);
        const currentTx = parseFloat(piece.dataset.tx);
        const currentTy = parseFloat(piece.dataset.ty);
        
        state.dragOffset.x = pt.x - currentTx;
        state.dragOffset.y = pt.y - currentTy;
    }

    function drag(e) {
        if (!state.draggedElement) return;
        e.preventDefault();
        
        const svg = document.querySelector('#puzzle-area svg');
        const pt = getEventPoint(e, svg);
        
        const newX = pt.x - state.dragOffset.x;
        const newY = pt.y - state.dragOffset.y;
        
        state.draggedElement.dataset.tx = newX;
        state.draggedElement.dataset.ty = newY;
        state.draggedElement.setAttribute("transform", `translate(${newX}, ${newY})`);
    }

    function endDrag(e) {
        if (!state.draggedElement) return;
        
        const piece = state.draggedElement;
        const name = piece.dataset.id;
        const svg = document.querySelector('#puzzle-area svg');
        
        piece.classList.remove('dragging');
        state.draggedElement = null;

        const tx = parseFloat(piece.dataset.tx);
        const ty = parseFloat(piece.dataset.ty);
        const dist = Math.sqrt(tx*tx + ty*ty);

        if (dist < 20) {
            piece.setAttribute("transform", "translate(0, 0)");
            piece.classList.add('snapped');
            piece.dataset.tx = 0;
            piece.dataset.ty = 0;
            
            addLabelToPuzzlePiece(piece, name, svg);
            
            const feedback = document.querySelector('#puzzle-game-ui #feedback-bar');
            feedback.innerText = "PLACED: " + name.toUpperCase();
            feedback.className = 'correct visible';

            state.puzzlePiecesLeft--;
            state.score += 20;
            state.testCorrect++; 
            document.getElementById('score-display').innerText = "SCORE: " + state.score;

            if (state.puzzlePiecesLeft <= 0) {
                feedback.innerText = "REGION COMPLETE!";
                state.testTotal++; 
                setTimeout(nextPuzzleRound, 1500);
            } else {
                setTimeout(() => {
                    if (state.puzzlePiecesLeft > 0) {
                        feedback.innerText = "NEXT PIECE...";
                        feedback.className = 'visible';
                    }
                }, 1000);
            }
        } else {
            const feedback = document.querySelector('#puzzle-game-ui #feedback-bar');
            feedback.innerText = "NOT QUITE...";
            feedback.className = 'wrong visible';
        }
    }

    function getEventPoint(e, svg) {
        let p = svg.createSVGPoint();
        if (e.touches && e.touches.length > 0) {
            p.x = e.touches[0].clientX;
            p.y = e.touches[0].clientY;
        } else {
            p.x = e.clientX;
            p.y = e.clientY;
        }
        return p.matrixTransform(svg.getScreenCTM().inverse());
    }

    function nextPuzzleRound() {
        state.currentIdx++;
        loadPuzzleRound();
    }


    // --- QUIZ HELPERS ---
    
    function loadCapitalRound() {
        if (state.currentIdx >= state.pool.length) { showReport(); return; }
        const targetState = state.pool[state.currentIdx];
        document.getElementById('capital-state-name').innerText = targetState.name.toUpperCase();
        const feedback = document.querySelector('#capitals-game-ui #feedback-bar');
        feedback.classList.remove('visible'); feedback.className = ''; 
        const previewContainer = document.getElementById('capital-state-preview');
        previewContainer.innerHTML = ''; 
        const ns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(ns, "svg");
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", targetState.path);
        svg.appendChild(path);
        previewContainer.appendChild(svg);
        setTimeout(() => { try { const bbox = path.getBBox(); const pad = 30; svg.setAttribute("viewBox", `${bbox.x - pad} ${bbox.y - pad} ${bbox.width + (pad*2)} ${bbox.height + (pad*2)}`); } catch(e) {} }, 10);
        const correctOption = { name: targetState.capital, isCorrect: true };
        const distractorsPool = state.allData.filter(s => s.name !== targetState.name);
        const shuffledDistractors = distractorsPool.sort(() => 0.5 - Math.random()).slice(0, 3);
        const options = shuffledDistractors.map(s => ({ name: s.capital, isCorrect: false }));
        options.push(correctOption);
        state.currentOptions = options.sort(() => 0.5 - Math.random());
        for(let i=0; i<4; i++) { const btn = document.getElementById(`opt-${i}`); btn.innerText = state.currentOptions[i].name.toUpperCase(); btn.classList.remove('correct-anim', 'wrong-anim'); btn.disabled = false; }
    }

    function checkCapital(idx) {
        const selected = state.currentOptions[idx];
        const btn = document.getElementById(`opt-${idx}`);
        const feedback = document.querySelector('#capitals-game-ui #feedback-bar');
        feedback.classList.add('visible');
        for(let i=0; i<4; i++) document.getElementById(`opt-${i}`).disabled = true;
        state.testTotal++;
        if (selected.isCorrect) {
            state.testCorrect++; state.score += 10; document.getElementById('score-display').innerText = "SCORE: " + state.score;
            btn.classList.add('correct-anim'); feedback.className = 'correct visible'; feedback.innerText = "CORRECT!"; setTimeout(nextCapitalRound, 1000);
        } else {
            btn.classList.add('wrong-anim'); feedback.className = 'wrong visible';
            const correctCap = state.currentOptions.find(o => o.isCorrect).name.toUpperCase();
            const stateName = document.getElementById('capital-state-name').innerText;
            feedback.innerText = `NO... THE CAPITAL OF ${stateName} IS ${correctCap}`;
            state.currentOptions.forEach((opt, i) => { if(opt.isCorrect) document.getElementById(`opt-${i}`).classList.add('correct-anim'); });
            const win = document.getElementById('game-screen'); void win.offsetWidth; win.classList.add('shake-effect'); setTimeout(nextCapitalRound, 3000); 
        }
    }
    
    function nextCapitalRound() { const win = document.getElementById('game-screen'); win.classList.remove('shake-effect'); state.currentIdx++; loadCapitalRound(); }

    function loadTriviaRound() {
        if (state.currentIdx >= state.pool.length) { showReport(); return; }
        const qData = state.pool[state.currentIdx];
        document.getElementById('trivia-state-name').innerText = qData.state.toUpperCase();
        document.getElementById('trivia-question-text').innerText = qData.question;
        const feedback = document.querySelector('#trivia-game-ui #feedback-bar');
        feedback.classList.remove('visible'); feedback.className = ''; 
        let optionsObj = qData.options.map(opt => ({ text: opt, isCorrect: opt === qData.answer }));
        state.currentOptions = optionsObj.sort(() => 0.5 - Math.random());
        for(let i=0; i<4; i++) { const btn = document.getElementById(`triv-${i}`); btn.innerText = state.currentOptions[i].text; btn.classList.remove('correct-anim', 'wrong-anim'); btn.disabled = false; }
    }

    function checkTrivia(idx) {
        const selected = state.currentOptions[idx];
        const btn = document.getElementById(`triv-${idx}`);
        const feedback = document.querySelector('#trivia-game-ui #feedback-bar');
        feedback.classList.add('visible');
        for(let i=0; i<4; i++) document.getElementById(`triv-${i}`).disabled = true;
        state.testTotal++;
        if (selected.isCorrect) {
            state.testCorrect++; state.score += 15; document.getElementById('score-display').innerText = "SCORE: " + state.score;
            btn.classList.add('correct-anim'); feedback.className = 'correct visible'; feedback.innerText = "CORRECT!"; setTimeout(nextTriviaRound, 1000);
        } else {
            btn.classList.add('wrong-anim'); feedback.className = 'wrong visible';
            const correctText = state.currentOptions.find(o => o.isCorrect).text;
            feedback.innerText = `WRONG. ANSWER WAS: ${correctText.toUpperCase()}`;
            state.currentOptions.forEach((opt, i) => { if(opt.isCorrect) document.getElementById(`triv-${i}`).classList.add('correct-anim'); });
            const win = document.getElementById('game-screen'); void win.offsetWidth; win.classList.add('shake-effect'); setTimeout(nextTriviaRound, 3000); 
        }
    }

    function nextTriviaRound() { const win = document.getElementById('game-screen'); win.classList.remove('shake-effect'); state.currentIdx++; loadTriviaRound(); }

    function loadMapRound() {
        state.roundAttempts = 0; state.roundResolved = false;
        document.querySelectorAll('path').forEach(p => { p.classList.remove('highlighted', 'wrong', 'correct'); });
        if (state.currentIdx >= state.pool.length) { showReport(); return; }
        const target = state.pool[state.currentIdx];
        const feedback = document.querySelector('#map-game-ui #feedback-bar');
        feedback.className = 'visible'; feedback.innerText = `FIND: ${target.name.toUpperCase()}`;
    }

    function handleMapClick(clickedState) {
        if (state.roundResolved || state.currentIdx >= state.pool.length) return;
        const correct = state.pool[state.currentIdx];
        const feedback = document.querySelector('#map-game-ui #feedback-bar');
        const win = document.getElementById('game-screen');
        const clickedEl = document.getElementById("map-" + clickedState.name.replace(/\s/g, ''));
        if (state.roundAttempts === 0) state.testTotal++;
        if (clickedState.name === correct.name) {
            state.roundResolved = true; clickedEl.classList.add('correct'); feedback.className = 'correct visible';
            if (state.roundAttempts === 0) { state.testCorrect++; state.score += 15; feedback.innerText = "EXCELLENT!"; } else { state.score += 5; feedback.innerText = "CORRECT!"; }
            document.getElementById('score-display').innerText = "SCORE: " + state.score; setTimeout(nextMapRound, 1000);
        } else {
            win.classList.remove('shake-effect'); void win.offsetWidth; win.classList.add('shake-effect');
            clickedEl.classList.add('wrong');
            if (state.roundAttempts === 0) {
                state.roundAttempts++; feedback.classList.add('wrong', 'visible'); feedback.innerText = `THAT IS ${clickedState.name.toUpperCase()}. TRY AGAIN.`;
            } else {
                state.roundResolved = true;
                const correctID = "map-" + correct.name.replace(/\s/g, '');
                const correctEl = document.getElementById(correctID);
                if (correctEl) correctEl.classList.add('highlighted');
                feedback.classList.add('wrong', 'visible'); feedback.innerText = `WRONG. THAT WAS ${correct.name.toUpperCase()}.`;
                setTimeout(() => { nextMapRound(); }, 2500);
            }
        }
    }

    function nextMapRound() { const win = document.getElementById('game-screen'); win.classList.remove('shake-effect'); state.currentIdx++; loadMapRound(); }

    function showReport() {
        const pct = state.testTotal === 0 ? 0 : Math.round((state.testCorrect / state.testTotal) * 100);
        document.getElementById('report-percent').innerText = pct + "%";
        document.getElementById('report-fraction').innerText = `${state.testCorrect} / ${state.testTotal} Correct`;
        document.getElementById('report-modal').style.display = 'flex';
    }

    function closeReport() { document.getElementById('report-modal').style.display = 'none'; quitGame(); }

    loadAllData(); 

</script>
</body>
</html>


